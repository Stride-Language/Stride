
# Serial Domains

constant _SerialBaudRate  { # Overriden by configuration
	value: 9600
}

constant _SerialPort  { # Overriden by configuration
	value: '"/dev/ttyACM0"'
}

resource SerialPort {
	substitutions: ["baud_rate", _SerialBaudRate,
					"serial_port", _SerialPort,
					"serial_process_rate", SerialProcessRate ]
    resourceIncludes: ['serial/serial.h']
    resourceDeclarations: [
		"serial::Serial serialPort(%%serial_port%%, %%baud_rate%%, serial::Timeout::simpleTimeout(1.0/%%serial_process_rate%%));"
		]
}


constant SerialProcessRate {
	value: 1000
}
 
_domainDefinition SerialDomain {
	domainName: "SerialDomain"
	framework: _RtAudioFramework
	parentDomain: RootDomain
	rate: SerialProcessRate
	resource: SerialPort
    substitutions: ["serial_port", _SerialPort,
					"serial_process_rate", SerialProcessRate]
    domainIncludes: ["<thread>", 'serial/serial.h']
    domainDeclarations: ["void serial_thread_func();",
		"bool serialthread_running {true};",
		"std::thread serialReadThread(serial_thread_func);"]
    domainInitializationCode: ""
    	domainProcessingCode: '
    // Serial domain
    '
	domainFunctionCode: "
void serial_thread_func() {
		std::string mLineBuffer;
		int mGranularity = 1000000.0/%%serial_process_rate%%; // nanoseconds
//[[Initialization]]
//[[/Initialization]]
  // Flush buffers
  //my_serial.flush();
  std::string lineBuffer; // Stores partial lines between reads
  const unsigned int bufferSize = 4096;
  uint8_t buffer[bufferSize];
  while (serialthread_running) {
    auto nextTime = std::chrono::high_resolution_clock::now() + std::chrono::nanoseconds(mGranularity);
//[[Processing]]
//[[/Processing]]


  }
}
	"
    domainCleanupCode: '
	serialthread_running = false;
	serialReadThread.join();
	std::cout << "Serial Thread joined." << std::endl;
	'
}


_domainDefinition SerialOutDomain {
	domainName: "SerialOutDomain"
	framework: _RtAudioFramework
	parentDomain: SerialDomain
	rate: 0
  domainInitializationCode: ''
	domainFunctionCode: ''
	domainProcessingCode: '//[[Processing]]
//[[/Processing]]

    //        size_t bytes_wrote = my_serial.write(test_string);
'
    domainCleanupCode: ''
}

_domainDefinition SerialInDomain {
	domainName: "SerialInDomain"
	framework: _RtAudioFramework
	parentDomain: SerialDomain
	rate: 0
  domainInitializationCode: '// Init SerialInDomain'
	domainFunctionCode: '//SerialInDomain()'
	domainProcessingCode: "    try {
      size_t count = serialPort.read(buffer, bufferSize);
//      mRingBuffer.write((char *) buffer, count);
//      onInput(buffer, count);
				
	if (count > 0) {
    size_t start = 0;
    size_t nullPos = 0;
    while(nullPos <= count) {
      if (buffer[nullPos] == '\n' || buffer[nullPos] == '\r') {
        buffer[nullPos] = '\0';
        char *thisLine = (char *) buffer + start;
        mLineBuffer += std::string(thisLine);
        if (mLineBuffer.size() > 0) {
          // Process line
			auto separatorIndex = mLineBuffer.find(':');
      		size_t _id = std::stoi(mLineBuffer.substr(0, separatorIndex));
      		std::string _value = mLineBuffer.substr(separatorIndex + 1);
      		float serialVar = std::stof(_value);				
//[[Processing]]
//[[/Processing]]
          	mLineBuffer.clear();
        }
        start = nullPos + 1;
      }
      nullPos++;
    }
    if (start < count) {
      char *thisLine = (char *) buffer + start;
      buffer[count] = '\0';
      mLineBuffer += std::string(thisLine);
    }
  }
      std::this_thread::sleep_until(nextTime);
    } catch (const serial::PortNotOpenedException &/*e*/) {
      serialthread_running = false;

    } catch (const serial::IOException &/*e*/) {
      serialthread_running = false;

    }"
    domainCleanupCode: '// Cleanup SerialInDomain'
}

_domainDefinition SerialChannelDomain {
	domainName: "SerialChannelDomain"
	framework: _RtAudioFramework
	parentDomain: SerialDomain
	maxInstances: none
	rate: 0
    domainInitializationCode: ''
	domainFunctionCode: ''
	domainProcessingCode: '//[[Processing]]
//[[/Processing]]'
    domainCleanupCode: ''
}


# Serial ------------------------


platformBlock _SerialOutput {
    typeName: '_serialOutput'
#	numInputs: 0
	inputs: ["real"]
#    include: []
#    linkTo: []
#    declarations: ['']
#    initializations: [""]
    processing: "// Serial in[%%bundle_index%%] =  %%intoken:0%%;"
    domain: SerialOutDomain
	rate: SerialProcessRate
    inherits: [_Signal]
}


platformBlock _SerialInput {
    typeName: '_serialInput'
#	numInputs: 0
	outputs: ["real"]
#    include: []
#    linkTo: []
#    declarations: ['']
#    initializations: [""]
    processing: "// Serial in[%%bundle_index%%] =  %%intoken:0%%;"
    domain: SerialInDomain
	rate: SerialProcessRate
    inherits: [_Signal]
}

platformBlock _SerialPrintType {
    typeName: '_serialPrintType'
	inputs: ["string", "string"]
#	outputs: 0
#   include: ["serial/serial.h", "iostream"]
	linkDir: ["serial/build"]
#    linkTo: ["serial"]
#    declarations: ['']
    initializations: ["// Not implemented"]
    processing: "//my_serial.write(test_string);
"
    inherits: [_Signal]
}


platformModule SerialChannelIn {
	domain: SerialChannelDomain
	inputs: []
	outputs: ["string"]
	ports: [
		_platformModulePort IdPort {
			name: "id"
			default: 0
		}
	]
	declarations: [''
	]
	initializations: [ '' ]
	globalDeclarations: []
	globalInitializations: []
	preProcessing: 'if (_id == %%property:id%%) {'
    processing: "serialVar"
	postProcessing: '} // id %%property:id%%	'
    inherits: [_Signal]
}

constant _NumSerialInChannels {value: 2}

_serialInput SerialIn[_NumSerialInChannels] {
    rate: SerialProcessRate
    domain: SerialInDomain
}

constant _NumSerialOutChannels {value: 2}

_serialOutput SerialOut[_NumSerialOutChannels] {
    rate: SerialProcessRate
    domain: SerialOutDomain
}