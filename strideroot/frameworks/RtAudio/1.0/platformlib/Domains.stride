
_domainProcessing _PlatformDomainProcessing {
	domainStreams: [
		SetupDomain >> AsyncDomain >> SerialDomain >> AudioDomain;
		# Should perhaps look like:
		#SetupDomain >> [AudioDomain, AsyncDomain, SerialDomain];
		# But for now just setting the domain processing order
	]
}

_frameworkDescription _RtAudioFramework {
    frameworkName: "RtAudio"
}

alias PlatformDomain {
    block: AudioDomain
}

alias PlatformRate {
    block: AudioRate
}

alias _ContextInitDomain {
    block: SetupDomain
}

_domainDefinition SetupDomain {
	domainName: "SetupDomain"
	framework: _RtAudioFramework
	rate: -1 # -1 is 'one-shot/final' domain
	globalsTag: "Includes"
	declarationsTag: "Declarations"
	processingTag: "Initialization"
	initializationTag: "Initialization"
	cleanupTag: "Initialization"
    substitutions: [ ]
    domainIncludes: []
    domainDeclarations: []
    domainInitialization: '// setup domain init
		%%domainCode%%
		__setup__();
		'
	domainFunction: 'void __setup__() {
		%%domainCode%%
	}
		'
  domainCleanup: '// setup domain cleanup'
}

constant AsyncRate {
	value: 1000
}

_domainDefinition AsyncDomain {
	domainName: "AsyncDomain"
	framework: _RtAudioFramework
	rate: AsyncRate
	globalsTag: "Includes"
	declarationsTag: "Declarations"
	processingTag: "Processing"
	initializationTag: "Initialization"
	cleanupTag: "Cleanup"
    substitutions: ["domain_rate", AsyncDomain.rate ]
    domainIncludes: ['thread', 'chrono', 'iostream']
    domainDeclarations: ["void thread_func();",
		"std::thread asyncthread(thread_func);",
		"bool asyncthread_running {true};"]
    domainInitialization: "// init domain init"
	domainFunction: "// async domain processing
	void thread_func() {
		const int duration_ns = 1.0e9/%%domain_rate%%;
		while (asyncthread_running) {
			std::chrono::time_point<std::chrono::system_clock> start_time = std::chrono::system_clock::now();
	%%domainCode%%
			// TODO add overrun check
	auto end_time = start_time + std::chrono::nanoseconds(duration_ns);
    std::this_thread::sleep_until(end_time);

			}
}
	// end async domain processing
	"
    domainCleanup: '// init domain cleanup
	asyncthread_running = false;
	asyncthread.join();
	std::cout << "Thread joined." << std::endl;
	'
}

constant _SerialBaudRate  { # Overriden by configuration
	value: 9600
}

constant _SerialPort  { # Overriden by configuration
	value: '"/dev/ttyACM0"'
}

constant SerialProcessRate {
	value: 1000
}

_domainDefinition SerialDomain {
	domainName: "SerialDomain"
	framework: _RtAudioFramework
	rate: SerialProcessRate
	globalsTag: "Includes"
	declarationsTag: "Declarations"
	processingTag: "Processing"
	initializationTag: "Initialization"
	cleanupTag: "Cleanup"
    substitutions: ["baud_rate", _SerialBaudRate,
					"serial_port", _SerialPort,
					"serial_process_rate", SerialProcessRate ]
    domainIncludes: ['serial/serial.h', 'thread']
    domainDeclarations: ["void serial_thread_func();",
		"bool serialthread_running {true};",
		"float serialVar = 0.0;"]
    domainInitialization: "// serail domain init
	 std::thread serialReadThread(serial_thread_func);"
	domainFunction: "// serial domain processing function

void serial_thread_func() {
  serial::Serial my_serial(%%serial_port%%, %%baud_rate%%, serial::Timeout::simpleTimeout(1.0/%%serial_process_rate%%));

  // Flush buffers
  //my_serial.flush();
  std::string lineBuffer; // Stores partial lines between reads
  const unsigned int bufferSize = 32;
  uint8_t buffer[bufferSize];
  while (serialthread_running) {
    std::string input = lineBuffer + my_serial.read(bufferSize - 1);
    if (input.size() > 0) {
      size_t begin = 0;
      size_t count = 0;
      while (count < input.size()) {
        if (input[count] == '\r' || input[count] == '\n') {
          if (count - begin > 0) {
           serialVar = std::stof(input.substr(begin, count - begin)) ;
		   std::cout << serialVar <<std::endl;
		   %%domainCode%%
          }
          begin = count + 1;
        }
        count++;
      }
      lineBuffer.clear();
      if (begin != count) {
        lineBuffer = input.substr(begin);
      }


    }
  }
}
	"
    domainCleanup: '// init domain cleanup
	serialthread_running = false;
	serialReadThread.join();
	std::cout << "Serial Thread joined." << std::endl;
	'
}